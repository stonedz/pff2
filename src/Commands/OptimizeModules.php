<?php

declare(strict_types=1);

namespace pff\Commands;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Yaml\Parser;

/**
 * Precompiles module YAML configuration files into a single PHP array
 * stored at tmp/module-configs.php for fast production loading.
 */
class OptimizeModules extends Command
{
    protected function configure(): void
    {
        $this
            ->setName('optimize:modules')
            ->setDescription('Precompile module YAML configs into tmp/module-configs.php for production.');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $output->writeln('Precompiling module configurations...');

        $yamlParser = new Parser();
        $compiled = [];

        // Directories to scan for module config YAML files
        $searchDirs = [
            'app/config/modules',
            'app/modules',
            'modules',
            'vendor/stonedz/pff2/src/modules',
            'src/modules',
        ];

        foreach ($searchDirs as $dir) {
            $absDir = getcwd() . DIRECTORY_SEPARATOR . $dir;
            if (!is_dir($absDir)) {
                continue;
            }
            $this->scanDirectory($absDir, $dir, $yamlParser, $compiled, $output);
        }

        if (count($compiled) === 0) {
            $output->writeln('<comment>No module config files found to precompile.</comment>');
            return 0;
        }

        $tmpDir = getcwd() . DIRECTORY_SEPARATOR . 'tmp';
        if (!is_dir($tmpDir)) {
            mkdir($tmpDir, 0755, true);
        }

        $outPath = $tmpDir . DIRECTORY_SEPARATOR . 'module-configs.php';
        $content = "<?php\n\n// Auto-generated by optimize:modules — do not edit.\n// Generated: " . date('Y-m-d H:i:s') . "\n\nreturn " . var_export($compiled, true) . ";\n";
        file_put_contents($outPath, $content);

        $output->writeln('<info>Wrote ' . count($compiled) . ' config(s) to tmp/module-configs.php</info>');
        return 0;
    }

    /**
     * Recursively scan a directory for module.conf*.yaml files.
     *
     * The key used in the compiled array mirrors the relative path that
     * AModule::readConfig() receives (e.g. "pff2-doctrine/module.conf.local.yaml").
     */
    private function scanDirectory(string $absDir, string $relPrefix, Parser $yamlParser, array &$compiled, OutputInterface $output): void
    {
        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($absDir, \FilesystemIterator::SKIP_DOTS),
            \RecursiveIteratorIterator::LEAVES_ONLY
        );

        foreach ($iterator as $file) {
            /** @var \SplFileInfo $file */
            if (!$file->isFile()) {
                continue;
            }
            $name = $file->getFilename();
            if (!preg_match('/^module\.conf.*\.yaml$/', $name)) {
                continue;
            }

            $realPath = $file->getRealPath();
            // Build the config key as the path relative to the search dir root,
            // e.g. "pff2-doctrine/module.conf.local.yaml"
            $relPath = ltrim(str_replace($absDir, '', $realPath), DIRECTORY_SEPARATOR);

            try {
                $parsed = $yamlParser->parse(file_get_contents($realPath));
            } catch (\Symfony\Component\Yaml\Exception\ParseException $e) {
                $output->writeln('<error>Failed to parse ' . $relPath . ': ' . $e->getMessage() . '</error>');
                continue;
            }

            // Store under the relative key (first match wins — mirrors AModule priority)
            if (!isset($compiled[$relPath])) {
                $compiled[$relPath] = [
                    'hash' => sha1_file($realPath),
                    'config' => $parsed,
                ];
                $output->writeln('  Compiled: ' . $relPath);
            }
        }
    }
}
